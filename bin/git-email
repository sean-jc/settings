#!/bin/bash
branch=$(git rev-parse --abbrev-ref HEAD)
dir=$(pwd | rev | cut -d'/' -f1 | rev)

if [[ $# -lt 1 ]]; then
    printf "Must specify the mailing list\n"
    exit 1
fi
ml=$1

if [[ $# -lt 2 || $2 -lt 1 ]]; then
    printf "Must specify the (non-zero) number of patches\n"
    exit 1
fi
nr=$2

if [[ $# -lt 3 || $3 -lt 1 ]]; then
    printf "Must specify the (non-zero) series version\n"
    exit 1
fi
ver=$3

dir="$HOME/outbox/$dir"
if [[ ! -d $dir ]]; then
    printf "$dir is not a known repository for patches\n"
    exit 1
fi

dir="$dir/$ml"
if [[ ! -d $dir ]]; then
    printf "$dir is not a known mailing list for patches\n"
    exit 1
fi

branch=${branch//\//.}
dir="$dir/$branch/v$ver"
if [[ -n $redo ]]; then
    if [[ -n $indy ]]; then
        idir="$dir""_indy"
        if [[ ! -d $idir ]]; then
            printf "$idir doesn't exists, no existing patch(es) to send\n"
            exit 1
        fi
    fi
    if [[ ! -d $dir ]]; then
        printf "$dir doesn't exists, no existing patch(es) to send\n"
        exit 1
    fi
else
    if [[ -n $indy ]]; then
        printf "indy only works with redo\n"
        exit 1
    fi
    if [[ -d $dir ]]; then
        if [[ -n $ovr ]]; then
            rm -f $dir/*.patch
        else
            printf "$dir already exists, looks like you created this version already\n"
            exit 1
        fi
    else
        mkdir -p $dir
    fi

    opt=""
    if [[ $nr -gt 1 ]]; then
        opt="--cover-letter"
    fi
    if [[ $ver -gt 1 ]]; then
        opt="$opt -v $ver"
    fi
    if [[ -n $rfc ]]; then
        opt="$opt --rfc"
    fi

    pre=""
    if [[ -n $ku ]]; then
        pre="kvm-unit-tests "
    fi
    if [[ -n $resend ]]; then
        pre="$pre""RESEND "
    fi
    if [[ -n $rfc ]]; then
        pre="$pre""RFC "
    fi
    pre="$pre""PATCH"

    pre="--subject-prefix=\"$pre\""

    sh -c "git format-patch -M --minimal --patience $opt $pre -o $dir -$nr"

    if [ -f ./scripts/checkpatch.pl ]; then
        ./scripts/checkpatch.pl -g HEAD-$nr
    fi
fi

if [[ -n $nosend ]]; then
    exit 0
fi

opt=""
if [[ -n $reply ]]; then
    opt="--in-reply-to=$reply"
fi

while true; do
    printf "\n\n\e[1;7;35m--to=sean.j.christopherson@intel.com\n\e[0m"
    read -r -p "Send email: [Y/n]" response

    response=${response,,}    # tolower
    if [[ -z $response || $response =~ ^(yes|y)$ ]]; then
        if [[ -z $indy ]]; then
            if [[ $nr -gt 1 ]]; then
                grep -q -e "BLURB HERE" -e "SUBJECT HERE" $dir/*0000-cover-letter.patch
                if [ $? -eq 0 ]; then
                    printf "Edit the cover letter before sending!\n"
                    continue
                fi
            fi
            git send-email --suppress-cc=all --confirm=always --to=sean.j.christopherson@intel.com $opt $dir
        else
            for filename in $idir/*.patch; do
                git send-email --suppress-cc=all --confirm=always --to=sean.j.christopherson@intel.com $opt $filename
            done
        fi
        break
    else
        exit 0
    fi
done

if [[ -n $ku ]]; then
    to="--to=\"Paolo Bonzini <pbonzini@redhat.com>\" --to=\"Radim Krčmář <rkrcmar@redhat.com>\""
    cc="--cc=\"kvm@vger.kernel.org\""
elif [[ $ml == "sgx" && -z $to ]]; then
    to="--to=\"Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>\""
    cc="--cc=\"sgx@eclists.intel.com\""
fi

if [[ $ver -gt 1 ]]; then
    pre="v$ver-"
else
    pre=""
fi

if [[ -z $to ]]; then
    if [[ -n $indy ]]; then
        primary=$(ls -1 $idir/*000$indy*)
    elif [[ $nr -gt 1 ]]; then
        primary=$(ls -1 $dir/*0000*)
    else
        primary=$(ls -1 $dir/*0001*)
    fi

    to=$(~/go/src/github.com/sean-jc/settings/bin/git-to-cmd $primary $ml $pre)
    if [[ -z $to ]]; then
        printf "No --to found for %s\n" "git-to-cmd $primary $ml $pre"
        exit 1
    fi
    to="${to//\"/\\\"}"
    to="--to=\"${to//,/\" \-\-to=\"}\""

    if [[ -z $cc ]]; then
        cc=$(~/go/src/github.com/sean-jc/settings/bin/git-cc-cmd $primary $ml $pre)
        if [[ -z $cc ]]; then
            printf "No --cc found for %s\n" "git-cc-cmd $primary $ml $pre"
            exit 1
        fi
        cc="${cc//\"/\\\"}"
        cc="--cc=\"${cc//,/\" \-\-cc=\"}\""
    fi
fi
printf "\n\n\e[1;7;35m%s\n%s\n\e[0m" "$to" "$cc"
read -r -p "Send email: [Y/n]" response

response=${response,,}    # tolower
if [[ -z $response || $response =~ ^(yes|y)$ ]]; then
    if [[ -z $indy ]]; then
        eval $(printf "%s\n" "git send-email --confirm=always --suppress-cc=all $to $cc $opt $dir")
    else
        for filename in $idir/*.patch; do
            eval $(printf "%s\n" "git send-email --confirm=always --suppress-cc=cccmd $to $cc $opt $filename")
        done
    fi
fi
